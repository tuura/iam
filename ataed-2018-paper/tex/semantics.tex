This section present a methodology of assigning IAM programs with~\emph{modular}
semantics using a~\emph{polymorphic monadic metalanguage}. We call the semantics modular because,
once encoded in the metalanguage, it may be evaluated in different contexts yielding
meanings of a computation flavoured by the context.

Probably the most obvious context for an instruction architecture semantics is
stateful execution; interpreting the semantics in the~\hs{State} monad will yield
a simulator giving users the possibility to execute programs and observe
their behaviours. Section~\ref{sec:state-trans} presents a state transformer
semantics for IAM instructions.

Another interesting task is to build a~\emph{concurrency oracle} for computations.
A concurrency oracle is a function, which is able to identify if two computations
are~\emph{concurrent}, i.e. do not share any data dependencies.
In the section section~\ref{sec:oracles} we present a method of extracting
such oracles from the semantic definitions with certain properties.

Let us now formally define the polymorphic computational metalanguage which we will
later use to describe the semantics of the IAM instruction set.

\subsection{Polymorphic computational metalanguage}

\begin{definition}
\label{def:metalanguage}
% \textbf{Polymorphic monadic metalanguage}
A computational metalanguage is a type constructor $F$ equipped with two effectful
functions: $\forall k \forall v.r: k \rightarrow F v$ and
$\forall k \forall v.w: k \rightarrow F v \rightarrow F~\top$.
\end{definition}



We embed the metalanguage in Haskell using the following type:

\begin{minted}{haskell}
type Semantics c k v a = forall f. c f => (k -> f v)
                                       -> (k -> f v -> f ())
                                       -> Maybe (f a)
\end{minted}

A~\hs{Semantics} is essentially a rank-2 polymorphic\footnote{A rank-2 polymorphic
function is one taking as a parameter another function, which is in turn (rank-1)
polymorphic. This feature requires~\hs{RankNTypes} GHC extension to be enabled.}
effectful computation depending on two polymorphic functions,
which we will usually referred to as \hs{read} and~\hs{write}.


