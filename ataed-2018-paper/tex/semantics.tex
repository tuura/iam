This section present a methodology of assigning IAM programs with~\emph{modular}
semantics using a~\emph{polymorphic monadic metalanguage}. We call the semantics modular because,
once encoded in the metalanguage, it may be executed in several contexts yielding
multiple different meanings of a program. In this paper we will explore (i)
state transformer semantics (section~\ref{state-trans}) to simulate program
execution and produce traces, and (ii) data dependency semantics
(section~\ref{data-deps}) allowing to derive data flow graphs from programs and
observe possible concurrent behaviour.

\subsection{Polymorphic computational metalanguage}

\begin{definition}
% \textbf{Polymorphic monadic metalanguage}
A computational metalanguage is a monad $M$ equipped with two monadic
functions: $\forall k \forall v.r: k \rightarrow M v$ and
$\forall k \forall v.w: k \rightarrow v \rightarrow M~\top$.
\end{definition}

The intuition behind this metalanguage is a concept of a~\emph{store}. A simple
store instance is a mutable variable dictionary: a data structure associating
values to keys. A value of type $v$ can be read knowing its key of type $k$,
hence the type of read function $r$ is

We embed the metalanguage in Haskell using the following type:

\begin{minted}{haskell}
data Computetion tag k v a =
     Computetion { tag         :: tag
                 , computation :: forall m. Monad m =>
                                  (k -> m v) -> (k -> v -> m ()) -> m a }
\end{minted}

A~\hs{Computation} is essentially a rank-2 polymorphic\footnote{A rank-2 polymorphic
function is one taking as a parameter another function, which is in turn (rank-1)
polymorphic. This feature requires~\hs{RankNTypes} GHC extension to be enabled.}
monadic action (denoted as~\hs{computation} here) depending on two polymorphic functions,
which we will usually name \hs{read} and~\hs{write}.
The ~\hs{tag} field contains auxiliary information which may be used for various
purposes, such as to tell apart two identical computations.

The metalanguage resembles the~\hs{MonadState} type class:

\begin{minted}{haskell}
class Monad m => MonadState s m | m -> s where
    -- | Return the state from the internals of the monad.
    get :: m s
    get = state (\s -> (s, s))

    -- | Replace the state inside the monad.
    put :: s -> m ()
    put s = state (\_ -> ((), s))
\end{minted}

A~\hs{MonadState} is a~\hs{Monad} equipped with two extra functions: the first bringing
out the current state and the second substituting it with an external one.~\hs{MonadState}
is a powerful abstraction, which allows to emulate mutable state in a pure language.
However, we would like to employ a more general, yet 

\subsection{Program simulation}

\subsection{Data dependency extraction}