This section present a framework for describing the semantics of programming languages
in terms of a~\emph{polymorphic computational metalanguage}. We call the metalanguage
polymorphic because, once semantics is encoded in the metalanguage,
it may be evaluated in different contexts yielding meanings of a computation
flavoured by the context.

\begin{definition}
\label{def:metalanguage}
\textbf{Polymorphic computational metalanguage}\\
A polymorphic computational metalanguage is a type constructor $F$ equipped with
two effectful functions: $\forall k \forall v.r: k \rightarrow F v$ and
$\forall k \forall v.w: k \rightarrow F v \rightarrow F~\top$.
\end{definition}

We embed the metalanguage in Haskell using the following type:

\begin{minted}{haskell}
type Semantics c k v a = forall f. c f => (k -> f v)
                                       -> (k -> f v -> f ())
                                       -> Maybe (f a)
\end{minted}

A~\hs{Semantics} is essentially a rank-2 polymorphic\footnote{A rank-2 polymorphic
function is one taking as a parameter another function, which is in turn (rank-1)
polymorphic. This feature requires~\hs{RankNTypes} GHC extension to be enabled.}
effectful computation depending on two polymorphic functions,
which we will usually referred to as~\hs{read} and~\hs{write}.

Let us now give some intuition for the components of the metalanguage.
The~\hs{Semantics c k v a}
type may be thought as a mutable dictionary. The types~\hs{k} and~\hs{v} represent keys
and associated values. The~\hs{read} function has type~\hs{k -> f v} --- it takes
a key and gives back an effectful value looked up in the dictionary. The~\hs{write}
function takes a key and an effectful value to and alters the value of the key
with the value. The semantics is allowed to fail to produce a result, hence the
the return type~hs{f a} is wrapped in the~\hs{Maybe} type constructor.~\hs{Maybe}
\footnote{This type is defined in the Haskell base library as~\hs{data Maybe a = Just a | Nothing}}
is an idiomatic Haskell encoding of potentially faulty computations.

In this paper we use the defined metalanguage to encode the semantics of the
instruction set architecture of a simple computer. We call this computer
IAM~\footnote{Inglorious Haskell Machine}. The next section gives an overview of
its microarchitecture and instruction set, present the semantics of instructions
and programs in terms of the polymorphic computational metalanguage and two
instantiations of the semantics: stateful simulator and concurrent data access
analyser.



% Let us give an intuition on the possible evaluation contexts.
% Probably the most obvious one for an is stateful execution;
% interpreting the semantics in the~\hs{State} monad will yield
% a simulator giving users the possibility to execute computations and observe
% their behaviours.

% Another interesting task is to build a~\emph{concurrency oracle} for computations.
% A concurrency oracle is a function, which is able to identify if two computations
% are~\emph{concurrent}, i.e. do not share any data dependencies.
% In the section section~\ref{sec:oracles} we present a method of extracting
% such oracles from the semantic definitions with certain properties.



